#3.4 迭代器介绍

**迭代器(iterator)**

所有标准库容器都可以使用迭代器，但是只有几少数几种才同时支持下标运算符。



## 3.4.1 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员。

- `begin()`返回指向第一个元素的迭代器。

- `end()`返回指向容器（或string对象）尾迭代器。

  “尾元素的下一位置（one past the end）”的迭代器，也就是说，该迭代器指示的是容器的最后一个本不存在的**“尾后（off the end）”**元素。称为**尾后迭代器（off-the-end iterator）**或简称尾迭代器（iter iterator）。如果容器为空begin和end返回的是同一个迭代器。

#### 迭代器运算符

| 标准容器迭代器的运算符    | 描述                                       |
| -------------- | ---------------------------------------- |
| *iter          | 返回迭代器iter所指元素的**引用**                     |
| iter->mem      | 解引用iter并获取该元素的名为mem的成员等价于（*iter）.mem     |
| ++iter         | 令iter指示容器的下一个元素                          |
| --iter         | 令iter指示容器的上一个元书                          |
| iter1 == iter2 | 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等；否则，不相等 |
| iter1 != iter2 |                                          |

> 关键概念：泛型编程
>
> C++程序for循环中中更偏向于`!=`而不是`<`进行判断，原因是标准库容器的迭代器都定义了`==`和`!=`，但是大写是没有定义`<`运算符。

#### begin和end运算符

begin和end运算符的对象类型由对象是否常量决定，如果是常量返回`const_iterator`，否则返回`iterator`。

为了便于得到`const_iterator`的值，C++11引入两个新函数`cbegin`和`cend`

用于无论vector对象（或string）对象本身是否常量，返回值都是`const_iterator	`。

#### 结合解引用和成员访问操作

C++语言定义了**箭头运算符（->）**， 用于将解引用和成员访问两个操作结合在一起，也就是说`it -> mem`和`(*it).mem`表达的意思相同。



## 3.4.2 迭代器运算

string和vector的迭代器提供了更多额外的运算符，这些运算统称**迭代器运算（iterator）** 

| vector和string迭代器支持的运算 | 描述                                       |
| --------------------- | ---------------------------------------- |
| iter + n              | 迭代器加上一个整数仍得一个迭代器，迭代器指示的新位置与原来比较禺东路若干个元素。结果迭代器或者指示容器内的一个元素 ，或者指示容器尾元素的下一 |
| iter - n              |                                          |
| iter += n             |                                          |
| iter -= n             |                                          |
| iter1 - iter2         | 两个迭代器相减的结果就是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器，参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。**注意：C++没有定义加法** |
| >, >=, <, <=          | 迭代器的关系运算符，如果某迭代器执行指向的容器位置在另一个迭代器之前，则说亲爱则小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |

####迭代器的算术运算

两个迭代器相减，参与运算的是其名为**difference_type**的带符号整型数。

#### 使用迭代器运算

使用迭代器运算的一个经典算法是二分搜索

```c++
# include <iostream>
# include <string>
# include <cctype>
# include <vector>
using namespace std;
int main(){

    vector<int> test{1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto beg = test.begin(), end = test.end();
  	
  	//mid是一个迭代器而不是difference_type
  	auto  mid = beg + (end - beg) / 2;
    int target = 9;
  
  	//如果beg==end表示已搜索完，故结束循环
  	//如果*mid==target表示已找到，故结束循环
    while(beg != end && *mid != target){
        if(target>*mid){
            beg = mid + 1;
        }
        else if (target<*mid){
            end = mid - 1;
        }
      	mid = beg + (end -beg)/2;
      
        if(target==*mid){
            cout<<*mid<<endl;
            break;
        }
    }
}
```

