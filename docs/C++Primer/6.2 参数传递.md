# 6.2 参数传递

当参数是引用类型时，我们说它对应的实参被**引用传递（passed by reference）**或者函数被**传引用调用（called by reference）**。

当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被**值传递（passed by value）**或者函数被**传值调用（called by value）**。



##6.2.1 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。

#### 指针形参

指针的形容为和其它非引用类型一样。

> 熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。



## 6.2.2 传引用参数

#### 使用引用避免拷贝

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

> 如果函数无须改变引用形参的值，最好将其声明为常量引用。

#### 使用引用形参返回额外信息



## 6.2.3 形参和实参

当使用实参初始化形参时会忽略调顶层const。

```c++
void func(const int i) {/*func能够读取i，但是不能向i写值*/}
void func(int i) {}	//错误：重复定义了func(int)
```

C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别。

#### 尽量使用常量引用

使用普通引用而非常量引用会极大地限制函数所能接受的实参类型。例如，不能把const对象、字面值货值需要类型转换的对象传递给普通的引用形参。



## 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响：

1. 不允许拷贝数组
2. 使用数组时（通常）会将其转换成指针

因为不能拷贝数组，所以无法使用值传递

因为数组会转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

```c++
//三个等价形式
void print(const int*);
void print(const int[]);
void print(const int[10]);	//这里的维度表示我们期望数组含有多少元素，实际不一定
```

尽管表现形式不同，但上面的三个函数是等价的：每个函数的形参都是`const int *`。而传递给函数的数组实参，会自动转换成指针。

因为自动转换成指针，所以函数不知道数组的维度。

#### 使用标记指定数组长度

C风格的字符串存储在数组中，利用空字符标志字符串的结束。

#### 使用标准库规范

管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针。

```c++
void print(const int *beg, const int *end){
  //输出beg到end之间（不含end）的所有元素
  while(beg != end)
    cout<< *beg++ << endl;
}

//调用函数
int j[2] = {0,1};
print(begin(j), end(j));
```

#### 显示传递一个表示数组大小的形参

```c++
void print(const int ia [], size_t size){
  /**/
}
```

#### 数组引用形参

引用形参绑定到对应的实参上，也就是绑定到数组上：

```c++
//形参时数组的引用，维度是类型的一部分
void print(int (&arr)[10]){
  /**/
}
```

局限性：只能将函数用于大小为10的数组。

#### 传递多维数组

多维数组其实是数组的数组。

传递的数组的首元素指针其实是指向数组的指针，传递的数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能省略。

```c++
//martix指向数组的首元素，该数组的元素是由10个整数构成的数组
void print(int (*matrix)[10], int rowSize){ /**/ }
```
我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要将它包括在形参列表里：
```c++
//等价定义
void print(int martrix[][10] ,int rowSize) { /**/ }
```

```c++
# include <iostream>
# include <iterator>
using namespace std;

int count(int (*a)[2]){
    //a是指向第一个子数组的指针
    //*a是指向第一个子数组的第一个元素的指针
    //**a是第一个子数组的第一个元素
    for(int i = 0; i < 3; ++i){
        cout<<(**a)<<endl;
        a++;
    }
}
int main(){
    int b[3][2] = {{1,2},{3,4},{5,6}};
    for(auto i:b)
        cout<<i[0]<<endl;
    count(b);
}
```



##6.2.5 mian:处理命令行选项

main函数的形参接受命令行选项。

```c++
//命令行选项
prog -d -o ofile data0
```

```c++
int main(int argc, char *argc[]) {....}
```

- 第二个形参argv是一个数组，它的元素指向C风格字符串的指针；
- 第一个形参argc表示数组中字符串的数量。

argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。

```c++
argv[0] = "prog";	//或者argv[0]也可以指向一个空字符串
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = "0";
```



##6.2.6 含有可变形参的函数

为了编写能够处理不同数量实参的函数，C++新标准提供了两种主要方法：

- 如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型
- 如果实参类型不同，编写可变参数模版。

#### initializer_list形参

initializer_list是一种标准库类型，可用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。

| initializer_list                  | 描述                                       |
| --------------------------------- | ---------------------------------------- |
| initializer_list<T> lst;          | 默认初始化；T类型元素的空列表                          |
| initializer_list<T> lst{a,b,c...} | lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const |
| lst2(lst)                         | 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素 |
| lst2 = lst                        |                                          |
| lst.size()                        | 列表中的元素数量                                 |
| lst.begin()                       | 返回指向lst中首元素的指针                           |
| lst.end()                         | 返回指向lst中尾元素下一位置的指针                       |

initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。

> 只有当initializer_list对象的元素类型是类类型或容器类型（如string），才有必要把范围for循环的控制变量设为引用类型。

如果想向initializer_list形参中传递一个值的序列，必须把序列放到一对花括号内。

```c++
# include <iostream>
# include <iterator>
# include <initializer_list>
using namespace std;

int count(initializer_list<int> list){
    for(auto i : list)
        cout << i <<endl;
}
int main(){
    count({1, 2, 3, 4, 5});
}
```

####省略符形参

省略符形参应该仅仅适用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

省略符形参只能出现在形参列表的最后一个位置，他的形式无外乎以下两种：

```c++
void foo(parm_list, ...);
void foo(...);
```

