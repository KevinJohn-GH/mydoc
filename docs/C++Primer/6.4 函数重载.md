# 6.4 函数重载

同一作用域没的几个函数名字相同但是形参列表不同，我们称之为**重载（overloaded）函数**。

> mian函数不能重载

#### 重载和const形参

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。

另一方面，如果形参是某种类型的指针或引用，则通过区分指向的是常量对象，还是非常量对象可以实现函数重载，此时的const是底层的。

```c++
int func(const int *);	//作用于，指向int常量的指针
int func(int *);	//新函数，作用于int指针

int func(const int &);	//作用于，int常量的引用
int func(int &);	//新函数，作用于int引用
```

但是因为非常量可以转换成常量，所以无论是否有const的函数都能作用于非常量对象或者指向非常量对象的指针。但是编译器会优先选用非常量版本的函数。

#### 调用重载的函数

将函数调用与一组重载函数中的一个关联起来的过程叫做**函数匹配（function matching）**，也叫**重载确定（overload resolution）**

函数匹配三种可能的结果：

- 编译器找到一份与实参**最佳匹配（best match）**的函数，并产生调用该函数的代码。
- 找不到的任何一个函数与调用匹配的，此时编译器发出**无匹配（no match）**的错误信息。
- 有多于一个函数可以匹配，但是每一个都是明显的最佳选择。此时也将发生错误，称为**二义性调用（ambiguous call）**。



## 6.4.1 重载与作用域

在内层作用域声明名字，它将隐藏外层走哟用语中声明的同名实体。

> 在C++语言中，名字查找发生在类型检查之前。

