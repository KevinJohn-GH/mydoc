# 7.5 构造函数再探



## 7.5.1 构造函数初始值列表

当我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值。

这一区别到底会有声明深层次的影响完全依赖于数据成员的类型。

#### 构造函数的初始值有时必不可少

如果成员是const或者是引用的话，必须将其初始化。否则引起错误。

> 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表未这些成员提供初值。

> 建议：使用构造函数初始值

#### 成员初始化的顺序

构造函数初始值列表只说明用于初始化成员的值，而不限定初始值的具体执行顺序。成员初始化顺序与它们在类定义中出现的顺序一样。

一般来说，初始化的顺序没有特别有求。不过如果一个成员是用另一个成员初始化的，那么这两个成员的初始化顺序就很关键了。

> 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。这是不要再显示定义默认构造函数，会引起二义性。



## 7.5.2 委托构造函数

C++新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的**委托构造函数（delegating constructor）**。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。

```c++
class Sales_data{
public:
  //非委托构造函数使用对应的实参初始化成员
  Sales_data(std::string s, unsigned cnt, double price): bookNo(s), 	 units_sold(cnt), revenue(cnt*price){}
  //其余构造函数全都委托给另一个构造函数
  Sales_data() : Sales_data("", 0, 0) {}
  Sales_data(std::string s) : Sales_data(s, 0, 0) {}
  Sales_data(std::istream &is): Sales_data() { read(is, *this); }
}
```

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体依次执行，执行完成后，控制权才会交还给委托者的函数体。



## 7.5.3 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。

默认初始化执行默认构造函数的情况：

- 当在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
- 当类类型的成员没有在构造函数初始值列表中显示地初始化时。

值初始化执行默认构造函数的情况：

- 在数组初始化的过程中如果提供的初始值数量少于数组的大小时。
- 不使用初始值定义一个局部变量时。
- 通过书写形如`T()`的表达式显示地请求值初始化，其中T时类型名（vector的一个构造函数值接受一个实参用于说明vector的大小，他就是使用一个这种形式的实参来对它的元素初始化起进行值初始化）。

#### 使用默认构造函数

> 对于C++的新手程序员来说有一种常犯的错误：
>
> ```c++
> Sales_data obj();	//错误：声明了一个函数而非对象
> Sales_data obj2;	//正确：obj2是一个对象而非函数
> ```



## 7.5.4 隐式的类类型转换

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

```c++
string null_book = "9-999-99999-9";
//构造一个临时的Sales_data对象
//该对象的unitd_sold和revenue等于0，bookNo等于null_book
item.combine(null_book);	//编译器用给定的string自动创建了一个Sales_data对象，这个新生成的临时对象被传递给combine
```

这种临时对象，一旦combine完成就不能再访问了（这种临时对象被编译器看成是一种常量）。

#### 只允许一步类型转换

下面的代码隐式地使用两种转换规则，是错误的：

```c++
//错误：需要用户定义的两种转换：
//(1)把“9-999-99999-9”转换成string
//(2)把这个临时的string转换成Sales_data
item.combine("9-999-99999-9");
```

#### 抑制构造函数定义的隐式转换

在要求隐式转换的城西上下文中，可以通过将构造函数声明为**explicit**加以阻止。

只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。

#### explicit构造函数只能用于直接初始化

```c++
Sales_data item(null_book);	//正确：直接初始化
//错误：不能将explicit构造函数用于拷贝形式的初始化过程
Sales_data item2 = null_book;
```

> 当使用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器不会在自动转换过程中使用该构造函数。

#### 为转换显示地使用构造函数

尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显示地强制进行转换：

```c++
//正确：实参是一个显示的构造Sales_data对象
item.combine(Sales_data(null_book));
//正确：static_cast可以使用explicit的构造函数
item.combine(static_cast<Sales_data>(cin));
```

使用explicit的优点是避免因隐式类类型转换而带来意想不到的错误，缺点是当用户的确需要这样的类类型转换是，不得不使用略显烦琐的方式来实现。



## 7.5.5 聚合类

**聚合类（aggregate class）**使得用户可以直接访问其成员，并且有特殊的初始化语法形式。当一个类满足如下条件则是聚合的：

- 所有成员都是public的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有virtual函数。

定义聚合类的对象时，可直接用列表按顺序初始化聚合类的成员。



## 7.5.6 字面值常量类

除了算术类型、引用和指针外、某些类也是字面值类型。

数据成员都是字面值类型的聚合类是字面值类型类。如果不是聚合类，满足以下条件的也是字面值常量类：

- 数据成员都是字面值类型
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
- 类必须使用析构函数的E默认定义，该成员函数负责销毁类的对象。

constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。