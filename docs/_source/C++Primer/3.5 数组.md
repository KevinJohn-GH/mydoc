#3.5 数组

数组是一种类似于vector的数据结构，与vector不同的是，数组的大小确定不变，不能随意向数组中添加元素。



## 3.5.1 定义和初始化内置数组

数组是一个种复合类型。数组的声明如`a[b]`,其中b是数组的维度，在编译时已知，故维度必须是一个常量表达式。

```c++
usingned cnt = 42;
string bad[cnt];	//error:cnt must be constant 
```

默认情况下，数组的元素被默认初始化。

> 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组时必须定义数组的类型，不能使用`auto`。另外，和vector一样，数组的元素应为对象，因此不存在引用的数组。

#### 显示初始化数组元素

利用列表初始化时，可以忽略数组的维度。

#### 字符数组的特殊性

字符数组可以用字符串字面值初始化。当使用这种方式时，不要忘记字符串结尾处还有一个`\0`空字符。

```c++
char a[3] = "abc"; 	//error:字符数组维度不足，因为[4]
```

#### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

```c++
int a[] = {0, 1, 2, 3};
int a2[] = a; 	//error
a2 = a;		//error
```

> 一些编译器支持数组的赋值，这就是所谓的**编辑器扩展（compiler extension）**但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。

#### 理解复杂的数组声明

定义存放指针的数组比较简单和直接，但是定义数组的指针和数组的引用稍复杂。

```C++
int *ptrs[10];				//ptrs是含有10个整型指针的数组
int &refs[10] = /*???*/;	//错误：不存在引用的数组
int (*parray)[10] = &arr;	//Parrary指向一个含有10个整数的数组
int (&arrRef)[10] = arr;	//arrRef引用一个寒哟雨10个整数的数组
```

默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说：首先是定义的是一个大小为10的数组，它的名字是prts，然后知道数组里面存放的是指向int的指针。

但是对于Parray来说，从右向左理解不太合理。数组而言，应该由里向外阅读：

先看圆括号部分，可知是一个指针，再看右边，该指针指向的是一个维度为10的数组，再看左边，数组存放的是int类型。

当然，对修饰符的数量并没有特殊限制：

```c++
int *(&arry)[10] = ptrs;	//arry是数组的引用，该数组含有10个指向int类型的指针
```



## 3.5.2 访问数组元素

与标准库vector和string一样，数组的元素也能使用范围for语句或下标运算符来访问。

使用数组下标的时候，通常将其定义为**size_t**类型，size_t是一种机器相关的无法好类型，它被设计得足够大以便能表示内存中任意对象的大小。在头文件**cstddef**头文件中定义了size_t类型。

数组使用的下标运算符是由C++语言直接定义的，但是vector的下标运算符是库模版vector定义的。

> 大多数常见的安全问题都源于缓冲区溢出错误。当数组或其它类似数据结构下标越界并视图访问非法内存区域时，就会产生此类错误。



## 3.5.3 指针和数组

像其他对象一样，对数组元素使用取地址符就能得到指向该元素的指针：

```c++
string *p2 = &num[0];	//p指向nums的第一个元素
```

然而，数组还有一个特性：在很多用到数组名字的地方，编译器会之自动地将其替换为一个指向首元素的指针：

```c++
string *p2 = nums;	//等价于p2 = &nums[0]
```

> 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

```c++
int ia[] = {0,1,2,3}
auto ia2(ia);	//ia2是一个整型指针，指向ia的第一个元素，相当于auto ia2(&ia[0])
ia2 = 42;		//error：ia2是一个指针，不能用int值给指针赋值
```

当使用`decltype`关键字时不会发生上述转换。`decltype(ia)`返回的是由4个整数构成的数组。

#### 指针也是迭代器

vector和string的迭代器支持的运算，数组的指针全都支持。

要使用迭代器遍历数组元素，前提是获得指向数组的第一个元素的指针和指向数组尾元素的下一位置的指针。

获取数组第一个元素的两种方法：

- 通过数组名字
- 通过数组中首元素的地址

获取数组尾元素之后的那个不存在的元素的地址：

```c++
int *e = &arr[数组维度];	//指向arr尾元素的下一位置的指针
```

利用迭代器遍历数组：

```c++
for (int *b=arr; b!=e; ++b)
	cout<<*b<<endl;	//输出arr的元素
```

#### 标准库函数begin和end

```c++
int ia[] = {0, 1, 2, 3};
int *beg = begin(ia);	//指向ia首元素的指针
int *last = end(ia);	//指向arr尾元素的下一位置的指针
```

begin和end定义在`iterator`头文件中。

#### 指针运算

指针运算的功能与迭代器完全相同。

两个指针相减的结果的类型是一种名为**ptrdiff_t**的标准库类型，和size_t一样，ptrdiff_t也是一种定义在`cstddef`头文件中的机器相关类型。

#### 解引用和指针运算的交互

若指针指向了一个元素，则允许解引用该指针。

#### 下标和指针

很多情况下，使用数组的名字其实使用的是一个指向数组首元素的指针。对数组名字使用下标其实也是使用指针。

```c++
int i = ia[2];
//等价于
int *p = ia;
i = *(p+2);
```

 标准库类型限定使用的下标必须是无符号类型，但是内置的下标运算符无此要求。

```c++
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr[4];
int i = p[-2];	//p[-2]是arr[2]表示的元素
```



##3.5.4 C风格字符串

> 尽量避免使用C风格字符串。因为不方便，不安全。

字符串字面值是一种通用结构的数据，这种结构即是C++由C继承而来的**C风格字符串（C-style character string）**。

C风格字符串不是一种类型，而是为了表达和使用字符串二形成的一种约定俗成的写法：将字符串放在字符数组中并以**空字符结束（null terminated）**。

#### C标准库String函数

| C风格字符串的函数      | 描述                                       |
| -------------- | ---------------------------------------- |
| strlen(p)      | 返回p的长度，空字符不计算在内                          |
| strcmp(p1, p2) | 比较p1和p2的相等性。如果p1==p2，返回0；如果p1>p2,返回一个正值；如果p1<p2，返回一个负值。 |
| strcat(p1, p2) | 将p2附加到p1之后，返回p1                          |
| strcpy(p1, p2) | 将p2拷贝给p1，返回p1                            |



**注意**：strcat会从前面的字符串中寻找空字符`\0`，去除空字符后拼接字符串。不能对字符数组（即不含`\0`）直接使用上述函数，编译器会寻找`\0`空，产生不可预知的错误。

```c++
char a[10];		//初始化一个字符数组，其中不包含\0
strcat(a, "hello");		//试图将hello字符串拼接到字符数组	
//会产生无法预知的错误，编译器会一直在a中寻找\0空字符，直到找到为止
```



C风格的字符串不能与标准库string的比较（`>`,  `=`,  `>=`, `<=`,`+`）混用，因为C风格的字符串本质是数组，直接使用的时候其实真正使用的是指向数组首元素的指针。

```c++
char a = {'C', '+', '+'};	//error：没有以空字符结尾
char a = {'C', '+', '+'};	//正确
char b = "C++"; 	//正确
```

####目标字符串的大小由调用者指定

C风格字符串将两个字符串拼接，首先要提供一个用于存放字符串的数组，该数组必须足够大以便容纳下结果字符串以及末尾的空字符。

#### 为什么说两个指针相加没有意义

指针也是一个对象，与指针相关的属性有三个：

- 指针本身的值（value）
- 指针所指的对象（content）
- 指针本身在内存中的存储位置（address）

指针本身的值是一个内存地址值，表示指针所指对象在内存中的存储位置；指针所指的对象可以通过解引用指针访问；因为指针本身也是一个对象，所以指针也存储在内存的某个位置，它有自己的地址，固有“指针的指针”。

所以指针相加是没有意义的，但是指针相减是有意义的。如果两个指针指向同一个数组中的不同元素，则它们相减的结果代表了它们所指的元素在数组中的距离。



## 3.5.5与旧代码的接口

#### 混用stirng对象和C风格字符串

- 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧运算的运算对象。

上述性质反过来不成立。但是可以使用string的成员函数**c_str**给C风格的字符串赋值。

```c++
string s = "string";
char * c = s;	//error
const char *s = s.c_str();	//正确
```

`c_str`返回的是一个C风格的字符串，也就是一个指针。

`c_str` 返回的数组不会一直有效，会随s改变。最好重新拷贝一份。

#### 使用数组初始化vector对象

不允许使用一个数组尾另一个内质劣性的数组赋初始值，也不允许使用vector对象初始化数组。但是可以使用数组初始化vector：只需指明要拷贝取余的首元素和尾后地址就可以了。

```c++
int int_arr[] = {0, 1, 2, 3, 4};
vector<int> ivec(begin(int_arr), end(int_arr));
```

> 尽量使用标准库类型而非数组
>
> 使用指针和数组很容翻译出错。指针常用于底层操作。
>
> 现代C++程序应当尽量使用vector和迭代器，避免使用书组合指针：尽量使用string，避免使用C风格基于数组的字符串。









